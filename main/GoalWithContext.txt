<Goal>
ä»”ç»†è€ƒå¯Ÿç°æœ‰ç³»ç»Ÿçš„è®¾è®¡å’Œå®ç°æ–¹å¼ï¼Œçœ‹çœ‹æ˜¯å¦è¿˜æœ‰å¤§çš„æ”¹è¿›çš„ä½™åœ°ã€‚
</Goal>

<File name="/Users/yang/SysEvoV2/README.md"> 
è¿™æ˜¯ä¸€ä»½åŸºäºä¹‹å‰æ‰€æœ‰è®¨è®ºã€ä»£ç å®ç°åŠæ–°éœ€æ±‚ï¼ˆå‰åç«¯ä¸€ä½“åŒ–ã€å¤šç›®å½•æ”¯æŒï¼‰é‡æ–°æ•´ç†çš„**SysEvoV2 é¡¹ç›®æŠ€æœ¯è§„æ ¼è¯´æ˜ä¹¦**ã€‚

è¿™ä»½æ–‡æ¡£å»é™¤äº†æ‰€æœ‰æ–‡å­¦æ€§éšå–»ï¼Œé‡‡ç”¨äº†å·¥ç¨‹åŒ–ã€ç²¾ç¡®çš„æè¿°ï¼Œç¡®ä¿å®ç°æ—¶æ— æ­§ä¹‰ã€‚

---

# é¡¹ç›®è§„æ ¼è¯´æ˜ä¹¦ï¼šSysEvoV2 (è‡ªåŠ¨åŒ–ä»£ç æ¼”è¿›ç³»ç»Ÿ)

**ç‰ˆæœ¬:** v2.1 (Engineering Spec)
**æ—¥æœŸ:** 2026-01-20
**çŠ¶æ€:** å¼€å‘ä¸­ (In Development)
**ç¡¬ä»¶åŸºå‡†:** 8x NVIDIA RTX 3090 (192GB VRAM), Local Context Limit: 65k Tokens
**ç›®æ ‡æ¶æ„:** å‰åç«¯ä¸€ä½“åŒ– Monorepo (Golang + TypeScript)

---

## 1. ç³»ç»Ÿæ¦‚è¿° (System Overview)

SysEvoV2 æ˜¯ä¸€ä¸ªåŸºäº **AST æ„ŸçŸ¥** å’Œ **æ··åˆæ£€ç´¢** çš„è‡ªåŠ¨åŒ–ä»£ç ä¿®æ”¹ç³»ç»Ÿã€‚å®ƒæ—¨åœ¨è§£å†³å¤§è§„æ¨¡ä»£ç åº“ä¸­â€œä¸Šä¸‹æ–‡é€‰æ‹©ä¸å‡†â€å’Œâ€œè¡Œå·ä¿®æ”¹å¹»è§‰â€çš„æ ¸å¿ƒé—®é¢˜ã€‚

**æ ¸å¿ƒå·¥ä½œæµï¼š**

1. **ç´¢å¼• (Indexing):** å°†å¤šç›®å½•ä¸‹çš„æºç è§£æä¸º AST è¯­ä¹‰å— (Chunks) å¹¶å»ºç«‹ç¬¦å·ç´¢å¼•ã€‚
2. **ç­›é€‰ (Selection):** åŸºäºæ„å›¾åˆ©ç”¨æœ¬åœ° LLM ç­›é€‰éª¨æ¶ï¼Œå¹¶ç»“åˆç¬¦å·ç´¢å¼•è¿›è¡Œç¡®å®šæ€§ä¾èµ–æ‰©æ•£ã€‚
3. **ç”Ÿæˆ (Generation):** åˆ©ç”¨äº‘ç«¯ LLM ç”ŸæˆåŸºäº AST èŠ‚ç‚¹çš„å®Œæ•´æ›¿æ¢ä»£ç ã€‚
4. **åº”ç”¨ (Application):** é€šè¿‡æœ¬åœ° AST å®šä½è¿›è¡Œç²¾å‡†çš„ä»£ç æ›¿æ¢ä¸æ ¼å¼åŒ–ã€‚

---

## 2. è¯¦ç»†æ¶æ„è®¾è®¡ (Detailed Architecture)

ç³»ç»Ÿç”±ä¸‰ä¸ªæ ¸å¿ƒå­ç³»ç»Ÿç»„æˆï¼š**åˆ†æå±‚ (Analysis)**ã€**ä¸Šä¸‹æ–‡å±‚ (Context)**ã€**æ‰§è¡Œå±‚ (Execution)**ã€‚

### 2.1 ç»„ä»¶ Aï¼šä»£ç åº“åˆ†æä¸ç´¢å¼• (Codebase Analysis & Indexing)

è´Ÿè´£å°†é™æ€æ–‡ä»¶è½¬æ¢ä¸ºå¯æŸ¥è¯¢çš„è¯­ä¹‰æ•°æ®ç»“æ„ã€‚

* **è¾“å…¥:** * é…ç½®çš„ **æ ¹ç›®å½•åˆ—è¡¨ (Root Directories)**ï¼ˆæ”¯æŒå‰åç«¯å¤šç›®å½•ï¼Œå¦‚ `["./backend", "./frontend"]`ï¼‰ã€‚
* **æ ¸å¿ƒæ¨¡å—:** `analysis/indexer.go`
* **å¤„ç†æµç¨‹:**
1. **å¢é‡æ‰«æ:** éå†æŒ‡å®šç›®å½•ï¼Œå¯¹æ¯” `sys/files/meta` ä¸­çš„ä¿®æ”¹æ—¶é—´æˆ³ï¼Œä»…å¤„ç†å˜åŠ¨æ–‡ä»¶ã€‚
2. **AST åˆ‡åˆ† (Chunking):**
* **Golang:** ä½¿ç”¨ `go/ast` æå– `FuncDecl`, `GenDecl` (Struct/Interface)ã€‚
* **TypeScript:** è°ƒç”¨ Node.js Sidecar (`analyzers/ts/index.js`) è§£æ ASTã€‚
* **ç²’åº¦:** æœ€å°å•ä½ä¸ºâ€œè¯­ä¹‰å— (Chunk)â€ï¼ŒåŒ…å«å‡½æ•°ç­¾åã€æ³¨é‡ŠåŠå®Œæ•´å‡½æ•°ä½“ã€‚


3. **å…ƒæ•°æ®æå–:**
* `SymbolsDefined`: è¯¥å—å®šä¹‰çš„æ ‡è¯†ç¬¦ï¼ˆå¦‚å‡½æ•°åã€ç»“æ„ä½“åï¼‰ã€‚
* `SymbolsReferenced`: è¯¥å—å†…éƒ¨è°ƒç”¨çš„æ‰€æœ‰æ ‡è¯†ç¬¦ï¼ˆç”¨äºæ„å»ºä¾èµ–å›¾ï¼‰ã€‚


4. **æŒä¹…åŒ– (Storage):**
* **Chunk æ•°æ®:** å­˜å…¥ Redis Hash `sys/chunks`ã€‚
* **ç¬¦å·ç´¢å¼•:** å­˜å…¥ Redis Set `sys/idx/sym/{symbol}` (å€’æ’ç´¢å¼•: ç¬¦å· -> ChunkIDåˆ—è¡¨)ã€‚





### 2.2 ç»„ä»¶ Bï¼šä¸Šä¸‹æ–‡é€‰æ‹©å™¨ (Context Selector)

è´Ÿè´£æ ¹æ®ç”¨æˆ·æ„å›¾æ„å»ºæœ€å°ä¸”å®Œå¤‡çš„ä»£ç ä¸Šä¸‹æ–‡ã€‚

* **è¾“å…¥:** ç”¨æˆ·æ„å›¾ (Intent string)ã€‚
* **æ ¸å¿ƒæ¨¡å—:** `context/selector.go`
* **å¤„ç†æµç¨‹:**
1. **Level 0 (åŠ è½½):** ä» Redis åŠ è½½æ‰€æœ‰ Chunk çš„ **éª¨æ¶ (Skeleton)** (ä»…ç­¾å+æ³¨é‡Šï¼Œæ— å®ç°)ã€‚
2. **Level 1 (è¯­ä¹‰ç­›é€‰):** * å°†æ„å›¾å’Œéª¨æ¶åˆ—è¡¨è¾“å…¥æœ¬åœ° LLM (Agent/GLM-4.7)ã€‚
* LLM è¾“å‡ºä¸ä»»åŠ¡ç›´æ¥ç›¸å…³çš„ ChunkID åˆ—è¡¨ (JSON æ ¼å¼)ã€‚


3. **Level 2 (ä¾èµ–æ‰©æ•£):**
* éå† Level 1 é€‰ä¸­ Chunk çš„ `SymbolsReferenced`ã€‚
* æŸ¥è¯¢ `sys/idx/sym/*` ç´¢å¼•ï¼Œå¼ºåˆ¶æ‹‰å–å®šä¹‰äº†è¿™äº›ç¬¦å·çš„ Chunk (1-Hop ä¾èµ–)ã€‚
* *ç›®çš„:* ç¡®ä¿äº‘ç«¯æ¨¡å‹æ‹¥æœ‰ç±»å‹å®šä¹‰å’Œå·¥å…·å‡½æ•°çš„ä¸Šä¸‹æ–‡ï¼Œé¿å…å¹»è§‰ã€‚


4. **è¾“å‡º:** åŒ…å«å®Œæ•´ä»£ç ä½“ (Body) çš„ Chunk åˆ—è¡¨ã€‚



### 2.3 ç»„ä»¶ Cï¼šç”Ÿæˆä¸ç¼–è¾‘ (Generation & Editing)

è´Ÿè´£ç”Ÿæˆä¿®æ”¹æ–¹æ¡ˆå¹¶å®‰å…¨åœ°åº”ç”¨åˆ°ç£ç›˜ã€‚

* **è¾“å…¥:** å®Œæ•´ä¸Šä¸‹æ–‡ Chunk åˆ—è¡¨ + ç”¨æˆ·æ„å›¾ã€‚
* **æ ¸å¿ƒæ¨¡å—:** `workflow/goal_runner.go`, `editing/ast_editor.go`
* **ç”Ÿæˆç­–ç•¥ (Cloud Agent):**
* æ¨¡å‹: Google Gemini 3.0ã€‚
* åè®®: è¾“å‡º `CodeModification` ç»“æ„ã€‚
* **çº¦æŸ:** ç¦æ­¢ä½¿ç”¨è¡Œå·ã€‚å¿…é¡»ä½¿ç”¨ `TargetChunkID` å®šä½ï¼Œå¹¶æä¾›å®Œæ•´çš„ `NewContent` (AST èŠ‚ç‚¹å…¨é‡æ›¿æ¢)ã€‚


* **åº”ç”¨ç­–ç•¥ (AST Patching):**
1. **å®šä½:** è¯»å–ç›®æ ‡æ–‡ä»¶ï¼Œå®æ—¶è§£æ ASTï¼Œæ ¹æ® `TargetChunkID` (å¦‚ `User.Save`) åŒ¹é…æœ€æ–°çš„ Byte Offset (Start, End)ã€‚
2. **æ›¿æ¢:** æ‰§è¡Œå­—èŠ‚çº§æ›¿æ¢ã€‚
* *Modify:* æ›¿æ¢æŒ‡å®šèŒƒå›´ã€‚
* *Delete:* åˆ é™¤æŒ‡å®šèŒƒå›´ã€‚
* *Create/Append:* å†™å…¥æ–°æ–‡ä»¶æˆ–è¿½åŠ åˆ°æ–‡ä»¶æœ«å°¾ã€‚


3. **ä¿®å¤:** è°ƒç”¨ `goimports` (Go) æˆ– `prettier` (TS) è‡ªåŠ¨ä¿®å¤å¯¼å…¥è·¯å¾„å’Œæ ¼å¼ã€‚



---

## 3. æ•°æ®ç»“æ„è§„èŒƒ (Data Schema)

åŸºäº Doptime Framework çš„å­˜å‚¨å®šä¹‰ã€‚

### 3.1 å­˜å‚¨é”® (Storage Keys)

| Key Pattern | ç±»å‹ | ç”¨é€” |
| --- | --- | --- |
| `sys/chunks` | `Hash<string, *Chunk>` | å­˜å‚¨ä»£ç å—å®ä½“ã€‚Field ä¸º ChunkIDã€‚ |
| `sys/files/meta` | `Hash<string, int64>` | å­˜å‚¨æ–‡ä»¶ä¿®æ”¹æ—¶é—´æˆ³ï¼Œç”¨äºå¢é‡æ£€æŸ¥ã€‚ |
| `sys/idx/sym/{symbol}` | `Set<string>` | ç¬¦å·å€’æ’ç´¢å¼•ã€‚å­˜å‚¨å®šä¹‰è¯¥ç¬¦å·çš„ ChunkID é›†åˆã€‚ |
| `sys/solutions` | `Hash<string, *Solution>` | å­˜å‚¨ç”Ÿæˆçš„ä¿®æ”¹æ–¹æ¡ˆå†å²ã€‚ |

### 3.2 æ ¸å¿ƒæ¨¡å‹ (Models)

**Chunk (ä»£ç åŸå­)**

```go
type Chunk struct {
    ID                string   `json:"id"`                 // "filepath:Signature"
    Type              string   `json:"type"`               // "Function" | "Struct"
    Skeleton          string   `json:"skeleton"`           // ç­¾å + æ³¨é‡Š
    Body              string   `json:"body"`               // å®Œæ•´ä»£ç 
    SymbolsDefined    []string `json:"symbols_defined"`    // å®šä¹‰çš„ç¬¦å·
    SymbolsReferenced []string `json:"symbols_referenced"` // è°ƒç”¨çš„ç¬¦å·
    FilePath          string   `json:"file_path"`
}

```

**CodeModification (ä¿®æ”¹æŒ‡ä»¤)**

```go
type CodeModification struct {
    FilePath      string `json:"file_path"`
    TargetChunkID string `json:"target_chunk_id"` // é”šç‚¹ ID
    ActionType    string `json:"action_type"`     // MODIFY | DELETE | CREATE_FILE
    NewContent    string `json:"new_content"`     // å®Œæ•´çš„æ–° AST èŠ‚ç‚¹ä»£ç 
    Reasoning     string `json:"reasoning"`
}

```

---

## 4. å®æ–½è·¯çº¿å›¾ (Implementation Roadmap)

### Phase 1: åŸºç¡€æ¶æ„æ„å»º (Infrastructure)

* [x] **å­˜å‚¨å±‚:** å®ç° Redis Key å®šä¹‰ (`storage/keys.go`, `storage/index_client.go`)ã€‚
* [x] **è§£æå±‚ (Go):** å®ç° `go/ast` è§£æå™¨ (`analysis/parser_go.go`)ã€‚
* [x] **è§£æå±‚ (TS):** å®ç° Node.js Sidecar è§£æå™¨ (`analysis/parser_ts_sidecar.go`)ã€‚
* [x] **ç´¢å¼•å™¨:** æ›´æ–° `RunIncrementalIndexing` ä»¥æ”¯æŒä¼ å…¥**ç›®å½•åˆ‡ç‰‡ (`[]string`)**ï¼Œå¹¶ä¸²è”è§£æä¸å­˜å‚¨é€»è¾‘ã€‚

### Phase 2: ä¸Šä¸‹æ–‡é€‰æ‹© (Context Selection)

* [x] **Agent é›†æˆ:** ç§»æ¤æ—§ç‰ˆ Agent (`agent`, `models` åŒ…) åˆ°æ–°æ¶æ„ã€‚
* [x] **é€‰æ‹©å™¨:** å®ç° `context/selector.go`ï¼Œè”é€šæœ¬åœ° LLM ä¸ Redis ç´¢å¼•ã€‚

### Phase 3: ç”Ÿæˆä¸æ‰§è¡Œ (Execution)

* [x] **ç¼–è¾‘å™¨:** å®ç° `editing/ast_editor.go`ï¼Œå®ŒæˆåŸºäº AST çš„ç²¾å‡†æ›¿æ¢é€»è¾‘ã€‚
* [x] **å·¥ä½œæµ:** å®ç° `workflow/goal_runner.go`ï¼Œä¸²è” Context -> Cloud Agent -> Editor é—­ç¯ã€‚

---

## 5. å…³é”®é£é™©ä¸è§„é¿ (Risk Management)

1. **é£é™©:** ç›®å½•éå†é—æ¼ã€‚
* *è§„é¿:* `RunIncrementalIndexing` å…¥å£å‚æ•°å¼ºåˆ¶æ”¹ä¸º `rootDirs []string`ï¼Œå¹¶åœ¨é…ç½®ä¸­æ˜ç¡®åˆ—å‡ºæ‰€æœ‰æºç æ ¹ç›®å½•ï¼ˆå¦‚ `backend/`, `frontend/src/`ï¼‰ã€‚


2. **é£é™©:** éšå¼ä¾èµ–ä¸¢å¤±ï¼ˆå¦‚ Middlewareï¼‰ã€‚
* *è§„é¿:* ç¬¦å·ç´¢å¼•é‡‡ç”¨â€œå­—ç¬¦ä¸²å¼ºåŒ¹é…â€ç­–ç•¥ï¼ˆDirty Indexï¼‰ï¼Œå®æ»¥å‹¿ç¼ºã€‚


3. **é£é™©:** ä»£ç æ›¿æ¢å¯¼è‡´ Import ä¸¢å¤±ã€‚
* *è§„é¿:* ç¼–è¾‘å™¨åœ¨å†™å…¥æ–‡ä»¶åï¼Œ**å¼ºåˆ¶æ‰§è¡Œ** `goimports` (Go) æˆ–è‡ªåŠ¨å¯¼å…¥ä¿®å¤é€»è¾‘ã€‚


4. **é£é™©:** TypeScript è§£æç¯å¢ƒä¾èµ–ã€‚
* *è§„é¿:* é‡‡ç”¨ Sidecar æ¨¡å¼ï¼Œå°† TS è§£æå™¨ä½œä¸ºç‹¬ç«‹å­è¿›ç¨‹è¿è¡Œï¼Œä¸ä¾èµ–å®¿ä¸»é¡¹ç›®çš„ `node_modules`ã€‚



---

**æŒ‡ä»¤:**
æœ¬é¡¹ç›®æ–‡æ¡£ä½œä¸ºåç»­å¼€å‘çš„**å”¯ä¸€çœŸç†æ¥æº (Single Source of Truth)**ã€‚æ‰€æœ‰ä»£ç å®ç°å¿…é¡»ä¸¥æ ¼éµå¾ªä¸Šè¿°æ•°æ®ç»“æ„ä¸æµç¨‹å®šä¹‰ã€‚ </File>

<File name="/Users/yang/SysEvoV2/editing/ast_editor.go"> 
package editing

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"os"
	"os/exec"
	"strings"

	"sysevov2/models"
)

// ApplyModification æ‰§è¡Œå•ä¸ªä»£ç å˜æ›´
func ApplyModification(mod *models.CodeModification) error {
	fmt.Printf("ğŸ”¨ Applying edit to: %s [%s]\n", mod.FilePath, mod.ActionType)

	if mod.ActionType == "CREATE_FILE" {
		return os.WriteFile(mod.FilePath, []byte(mod.NewContent), 0644)
	}
	// å¤„ç†çº¯åˆ é™¤æ–‡ä»¶çš„æƒ…å†µ
	if mod.ActionType == "DELETE" && mod.TargetChunkID == "" {
		return os.Remove(mod.FilePath)
	}

	// 1. è¯»å–æºæ–‡ä»¶
	contentBytes, err := os.ReadFile(mod.FilePath)
	if err != nil {
		return err
	}

	// 2. å®æ—¶è§£æ AST
	fset := token.NewFileSet()
	node, err := parser.ParseFile(fset, mod.FilePath, contentBytes, parser.ParseComments)
	if err != nil {
		return fmt.Errorf("parse failed: %v", err)
	}

	// 3. å®šä½ç›®æ ‡ Chunk
	start, end := findChunkRange(fset, node, mod.TargetChunkID)

	// 4. æ‰§è¡Œæ›¿æ¢æˆ–è¿½åŠ 
	var newContent []byte

	// Case A: æˆåŠŸå®šä½åˆ°ç›®æ ‡ Chunk -> æ‰§è¡Œæ›¿æ¢æˆ–åˆ é™¤
	if start != -1 && end != -1 {
		if mod.ActionType == "DELETE" {
			newContent = append(contentBytes[:start], contentBytes[end:]...)
		} else {
			// MODIFY
			newContent = append(contentBytes[:start], []byte(mod.NewContent)...)
			newContent = append(newContent, contentBytes[end:]...)
		}
	} else {
		// Case B: æœªå®šä½åˆ°ç›®æ ‡

		// [ä¿®å¤æ ¸å¿ƒ]ï¼šå¦‚æœæ˜¯ MODIFY/DELETE ä¸”æ‰¾ä¸åˆ°ç›®æ ‡ï¼Œå¿…é¡»æŠ¥é”™ï¼
		// åªæœ‰æ˜ç¡®æ˜¯ "ADD" æˆ–è€…æ‰¾ä¸åˆ°æ—¶çš„ç‰¹å®šé€»è¾‘æ‰å…è®¸è¿½åŠ 
		if mod.ActionType == "MODIFY" || mod.ActionType == "DELETE" {
			return fmt.Errorf("chunk not found for %s: %s (offsets: -1, -1)", mod.ActionType, mod.TargetChunkID)
		}

		// åªæœ‰åœ¨é MODIFY æƒ…å†µä¸‹ï¼ˆä¾‹å¦‚æ˜ç¡®çš„ ADD æŒ‡ä»¤ï¼‰ï¼Œæ‰æ‰§è¡Œè¿½åŠ ä½œä¸ºå›é€€
		// è¿½åŠ æ¨¡å¼ (Fallback)
		// æ³¨æ„ï¼šå¦‚æœåŸæ–‡ä»¶æœ«å°¾æ²¡æœ‰æ¢è¡Œï¼Œæœ€å¥½è¡¥ä¸€ä¸ª
		sep := "\n\n"
		if len(contentBytes) > 0 && contentBytes[len(contentBytes)-1] != '\n' {
			sep = "\n" + sep
		}
		newContent = append(contentBytes, []byte(sep+mod.NewContent)...)
	}

	// 5. å†™å›æ–‡ä»¶
	if err := os.WriteFile(mod.FilePath, newContent, 0644); err != nil {
		return err
	}

	// 6. è‡ªåŠ¨ä¿®å¤ Imports (Goimports)
	if strings.HasSuffix(mod.FilePath, ".go") {
		exec.Command("goimports", "-w", mod.FilePath).Run()
	}

	return nil
}

// findChunkRange è¾…åŠ©å‡½æ•°ï¼šåœ¨ AST ä¸­å®šä½ ID
func findChunkRange(fset *token.FileSet, node *ast.File, chunkID string) (int, int) {
	// ä» chunkID "main.go:User.Save" æå– "User.Save"
	parts := strings.Split(chunkID, ":")
	// [ä¿®å¤]ï¼šå¢åŠ  TrimSpaceï¼Œé˜²æ­¢ "extractGoDefinitions " è¿™ç§å¸¦å°¾éšç©ºæ ¼çš„æƒ…å†µå¯¼è‡´ä¸åŒ¹é…
	targetName := strings.TrimSpace(parts[len(parts)-1])

	var start, end = -1, -1

	ast.Inspect(node, func(n ast.Node) bool {
		if start != -1 {
			return false
		} // å·²æ‰¾åˆ°

		switch x := n.(type) {
		case *ast.FuncDecl:
			// æ‹¼æ¥ Receiver åå­—
			name := x.Name.Name
			if x.Recv != nil && len(x.Recv.List) > 0 {
				recvType := ""
				// ... (åŸæœ‰ receiver å¤„ç†é€»è¾‘ä¿æŒä¸å˜) ...
				if star, ok := x.Recv.List[0].Type.(*ast.StarExpr); ok {
					if id, ok := star.X.(*ast.Ident); ok {
						recvType = id.Name
					}
				} else if id, ok := x.Recv.List[0].Type.(*ast.Ident); ok {
					recvType = id.Name
				}
				if recvType != "" {
					name = recvType + "." + name
				}
			}

			// [å»ºè®®]ï¼šå¦‚æœä½ çš„ ID ç³»ç»Ÿå¯èƒ½åŒ…å«åŒ…å (å¦‚ analysis.extractGoSymbols)ï¼Œ
			// ä½ å¯ä»¥åœ¨è¿™é‡ŒåŠ ä¸€ä¸ªé€»è¾‘ï¼šå¦‚æœ targetName åŒ…å«ç‚¹ä½†æ²¡åŒ¹é…ä¸Šï¼Œå°è¯•ä»…åŒ¹é…å‡½æ•°åéƒ¨åˆ†ã€‚
			if name == targetName {
				start = fset.Position(x.Pos()).Offset
				end = fset.Position(x.End()).Offset
			}
		// ... (GenDecl é€»è¾‘ä¿æŒä¸å˜) ...
		case *ast.GenDecl:
			if x.Tok == token.TYPE && len(x.Specs) > 0 {
				if ts, ok := x.Specs[0].(*ast.TypeSpec); ok {
					if ts.Name.Name == targetName {
						start = fset.Position(x.Pos()).Offset
						end = fset.Position(x.End()).Offset
					}
				}
			}
		}
		return true
	})
	return start, end
} </File>

<File name="/Users/yang/SysEvoV2/context/selector.go"> 
package context

import (
	"fmt"
	"strings"
	"text/template"

	"sysevov2/agent"
	"sysevov2/llm"
	"sysevov2/models"
	"sysevov2/storage"
	"sysevov2/utils"

	"github.com/samber/lo"
)

// SelectedContext å°è£…æœ€ç»ˆçš„é€‰æ‹©ç»“æœï¼šåŒ…å«é›¶æ•£çš„ Chunks å’Œè¢«å‡çº§ä¸ºå…¨é‡çš„æ–‡ä»¶
type SelectedContext struct {
	Chunks    []*models.Chunk   // é›¶æ•£çš„ä»£ç å—
	FullFiles map[string]string // è·¯å¾„ -> æ–‡ä»¶å†…å®¹ (è¢«â€œå‡æ ¼â€çš„æ–‡ä»¶)
}

type Selector struct {
	SelectionAgent   *agent.Agent
	FilesMustInclude []string
	// å‡æ ¼é˜ˆå€¼ï¼šå¦‚æœä¸€ä¸ªæ–‡ä»¶ä¸­è¶…è¿‡ 50% çš„ Chunk è¢«é€‰ä¸­ï¼Œè¯»å–å…¨é‡æ–‡ä»¶
	PromotionThreshold float64
}

type SelectionResult struct {
	SelectedIDs []string `description:"The list of Chunk IDs that are strictly necessary."`
}

func NewSelector() *Selector {
	t := template.Must(template.New("ContextSelector").Parse(`
You are a Code Context Selector. Analyze the Intent and the Candidates.
Return the IDs of chunks that are strictly necessary to fulfill the intent.
Do not select chunks that are irrelevant.

<Important Files>
{{.ImportantFiles}}
</Important Files>

<Intent>
{{.Intent}}
</Intent>

<Candidates>
{{.Candidates}}
</Candidates>

When you have identified the necessary Chunk IDs, you must use the provided tool function to submit the result.
Do not reply with just a Markdown list.
`))

	selAgent := agent.Create(t).WithToolCallMutextRun().WithModels(llm.ModelDefault)

	return &Selector{
		SelectionAgent:     selAgent,
		PromotionThreshold: 0.5, // è®¾å®šä¸º 50%
	}
}

// SelectRelevantChunks è¿”å›ç»“æ„åŒ–ä¸Šä¸‹æ–‡ï¼Œè€Œéç®€å•çš„ Slice
func (s *Selector) SelectRelevantChunks(intent string, model *llm.Model) (*SelectedContext, error) {
	fmt.Printf("ğŸ§  Selecting Context for: %.50s...\n", intent)

	// 1. åŠ è½½æ‰€æœ‰ Chunk
	allChunksMap, err := storage.ChunkStorage.HGetAll()
	if err != nil {
		return nil, fmt.Errorf("failed to load chunks from storage: %w", err)
	}
	allChunks := lo.Values(allChunksMap)

	// 2. æ„å»ºå€™é€‰åˆ—è¡¨ (Skeleton View)
	var sb strings.Builder
	for _, c := range allChunks {
		skel := c.Skeleton
		if len(skel) > 400 {
			skel = skel[:400] + "..."
		}
		sb.WriteString(fmt.Sprintf("ID: %s\n%s\n---\n", c.ID, skel))
	}

	// 3. Agent ç­›é€‰ (Level 1)
	var finalIDs []string
	keyedAgent := s.SelectionAgent.UseTools(llm.NewTool("PickChunks", "Select necessary code chunks (IDs)", func(res *SelectionResult) {
		finalIDs = res.SelectedIDs
	}))

	err = keyedAgent.Call(map[string]any{
		agent.UseModel:   model,
		"ImportantFiles": utils.WrapFilesInXML("ImportantFile", s.FilesMustInclude...),
		"Intent":         intent,
		"Candidates":     sb.String(),
	})
	if err != nil {
		return nil, fmt.Errorf("agent call failed: %w", err)
	}

	// 4. ä¾èµ–æ‰©æ•£ (Level 2)
	finalIDSet := s.expandDependencies(finalIDs, allChunksMap)

	// ==========================================
	// 5. å¯†åº¦è®¡ç®—ä¸è‡ªåŠ¨å‡æ ¼ (Scheme B Implementation)
	// ==========================================

	// A. ç»Ÿè®¡æ¯ä¸ªæ–‡ä»¶çš„æ€» Chunk æ•°
	fileTotalCounts := make(map[string]int)
	for _, c := range allChunks {
		fileTotalCounts[c.FilePath]++
	}

	// B. ç»Ÿè®¡æ¯ä¸ªæ–‡ä»¶è¢«é€‰ä¸­çš„ Chunk æ•°
	fileSelectedCounts := make(map[string]int)
	for id := range finalIDSet {
		if c, ok := allChunksMap[id]; ok {
			fileSelectedCounts[c.FilePath]++
		}
	}

	// C. åˆ¤å®šå“ªäº›æ–‡ä»¶éœ€è¦å‡æ ¼
	filesToPromote := make(map[string]bool)
	for filePath, selectedCount := range fileSelectedCounts {
		totalCount := fileTotalCounts[filePath]
		if totalCount == 0 {
			continue
		}

		ratio := float64(selectedCount) / float64(totalCount)
		// è§„åˆ™ï¼šé€‰ä¸­æ¯”ä¾‹ > é˜ˆå€¼ï¼Œæˆ–è€…æ–‡ä»¶æå…¶å¾®å°ï¼ˆåªæœ‰1ä¸ªChunkä¸”è¢«é€‰ä¸­ï¼‰
		if ratio >= s.PromotionThreshold || (totalCount == 1 && selectedCount == 1) {
			filesToPromote[filePath] = true
			fmt.Printf("ğŸ“‚ Auto-Promoting File (Density %.0f%%): %s\n", ratio*100, filePath)
		}
	}

	// D. ç»„è£…æœ€ç»ˆç»“æœ
	result := &SelectedContext{
		Chunks:    make([]*models.Chunk, 0),
		FullFiles: make(map[string]string),
	}

	// å¤„ç†å…¨é‡æ–‡ä»¶
	for filePath := range filesToPromote {
		content := utils.ReadFile(filePath)
		if content != "" {
			result.FullFiles[filePath] = content
		}
	}

	// å¤„ç†å‰©ä½™ Chunk (å¦‚æœæ‰€å±æ–‡ä»¶å·²è¢«å‡æ ¼ï¼Œåˆ™è·³è¿‡è¯¥ Chunk)
	for id := range finalIDSet {
		chunk, ok := allChunksMap[id]
		if !ok {
			continue
		}
		// åªæœ‰å½“æ–‡ä»¶ä¸åœ¨ FullFiles åˆ—è¡¨æ—¶ï¼Œæ‰æ·»åŠ  Chunk
		if !filesToPromote[chunk.FilePath] {
			result.Chunks = append(result.Chunks, chunk)
		}
	}

	fmt.Printf("âœ… Selected: %d Full Files, %d Individual Chunks\n", len(result.FullFiles), len(result.Chunks))
	return result, nil
}

// expandDependencies ä¿æŒä¸å˜...
func (s *Selector) expandDependencies(seeds []string, allChunks map[string]*models.Chunk) map[string]struct{} {
	// ... (ä¿æŒåŸæœ‰ä»£ç ä¸å˜)
	resultSet := make(map[string]struct{})
	uniqueSymbols := make(map[string]struct{})

	for _, id := range seeds {
		resultSet[id] = struct{}{}
		chunk, ok := allChunks[id]
		if !ok {
			continue
		}
		for _, refSymbol := range chunk.SymbolsReferenced {
			if len(refSymbol) > 1 {
				uniqueSymbols[refSymbol] = struct{}{}
			}
		}
	}

	symbolList := make([]string, 0, len(uniqueSymbols))
	for sym := range uniqueSymbols {
		symbolList = append(symbolList, sym)
	}

	if len(symbolList) > 0 {
		targetIDs, err := storage.Indexer.GetUnionLinks(symbolList)
		if err != nil {
			fmt.Printf("âš ï¸ Error fetching dependencies: %v\n", err)
		} else {
			for _, tid := range targetIDs {
				if _, exists := allChunks[tid]; exists {
					resultSet[tid] = struct{}{}
				}
			}
		}
	}
	return resultSet
} </File>

<File name="/Users/yang/SysEvoV2/utils/textFromfile.go"> 
package utils

import (
	"fmt"
	"os"
	"strings"

	"sysevov2/config"

	"github.com/dustin/go-humanize"
)

func WrapFilesInXML(xmlTag string, filenames ...string) string {
	var sb strings.Builder
	for _, filename := range filenames {
		content, err := os.ReadFile(filename)
		if err != nil {
			fmt.Printf("Error reading file %s: %v\n", filename, err)
			continue
		}
		text := string(content)
		text = strings.TrimSpace(text)
		if text != "" {
			sb.WriteString(fmt.Sprintf("\n<%s name=\"%s\">\n%s\n</%s>\n", xmlTag, filename, text, xmlTag))
		}
	}
	return sb.String()
}

// ReadFile reads and returns the trimmed content of a file.
// On error, prints a message and returns an empty string.
func ReadFile(filename string) string {
	content, err := os.ReadFile(filename)
	if err != nil {
		fmt.Printf("Error reading file %s: %v\n", filename, err)
		return ""
	}
	return strings.TrimSpace(string(content))
}

// ReadFileTo reads file content and assigns it to the target pointer
// if the content is non-empty. Returns whether assignment occurred.
// On read error, prints a message and returns false without assignment.
func ReadFileTo(filename string, target *string) bool {
	content := ReadFile(filename)
	if target != nil && content != "" {
		*target = content
		return true
	}
	return false
}

// GenerateAnnotatedXMLFromEvoRealms traverses EvoRealm directory structures,
// filters files via keep-map, skips binary/empty files, and generates XML output
// with metadata (filename, human-readable size) and line-numbered content.
func GenerateAnnotatedXMLFromEvoRealms(fileKeepMap map[string]bool, realms ...*config.EvoRealm) string {
	var sb strings.Builder
	for _, realm := range realms {
		realm.WalkDir(func(path, relativePath string, info os.FileInfo) (e error) {
			fmt.Printf("Processing file: %s\n", path)
			if len(fileKeepMap) > 0 {
				if _, ok := fileKeepMap[relativePath]; !ok {
					return nil
				}
			}

			// Read the file content
			content := ReadFile(path)
			if binaryFile := strings.Contains(content, "\x00") || len(content) == 0; binaryFile {
				return nil
			}
			fileSz := "\n<file-size>" + humanize.Bytes(uint64(len(content))) + "</file-size>"
			fileContent := "\n<file-content>\n" + LineNumberedFileContent(content, 1) + "\n</file-content>"

			fileinfo := fmt.Sprint("\n<file>\n<file-name>", relativePath, "</file-name>"+fileSz, fileContent, "\n</file>\n")

			sb.WriteString(fileinfo)
			return nil
		})
	}
	return sb.String()
} </File>

<File name="/Users/yang/SysEvoV2/models/models.go"> 
package models

// Chunk ä»£è¡¨ä¸€ä¸ªä»£ç åŸå­ï¼ˆå‡½æ•°/ç»“æ„ä½“/æ¥å£ï¼‰
type Chunk struct {
	// å”¯ä¸€æ ‡è¯†ç¬¦: "filepath:start_byte-end_byte"
	// msgpack: æ•°æ®åº“å­˜å‚¨å­—æ®µå
	ID string `json:"id" msgpack:"id"`

	// ç±»å‹: "Function", "Struct", "Interface"
	Type string `json:"type" msgpack:"type"`

	// éª¨æ¶: ä»…ç­¾å + æ³¨é‡Š (ç”¨äº Level 1 æ„å›¾ç­›é€‰)
	Skeleton string `json:"skeleton" msgpack:"skeleton"`

	// å…¨æ–‡: å®Œæ•´çš„ä»£ç å®ç° (ç”¨äº Level 3 ç”Ÿæˆ)
	Body string `json:"body" msgpack:"body"`

	// ç¬¦å·è¡¨: å®šä¹‰äº†ä»€ä¹ˆç¬¦å·
	SymbolsDefined []string `json:"symbols_defined" msgpack:"symbols_defined"`

	// å¼•ç”¨è¡¨: è°ƒç”¨äº†ä»€ä¹ˆç¬¦å· (ç”¨äºæ„å»ºè„é“¾æ¥å›¾)
	SymbolsReferenced []string `json:"symbols_referenced" msgpack:"symbols_referenced"`

	// æ–‡ä»¶å…ƒæ•°æ®: ç”¨äºå¢é‡æ›´æ–°æ£€æŸ¥
	FilePath  string `json:"file_path" msgpack:"file_path"`
	UpdatedAt int64  `json:"updated_at" msgpack:"updated_at"` // Unix Timestamp
} </File>

<File name="/Users/yang/SysEvoV2/analysis/parser_ts_sidecar.go"> 
package analysis

import (
	"bytes"
	"encoding/json"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"sysevov2/models"
)

// analyzerScriptPath å®šä¹‰åˆ†æå™¨è„šæœ¬çš„ç›¸å¯¹è·¯å¾„
// éƒ¨ç½²æ—¶ç¡®ä¿ analyzers ç›®å½•å’ŒäºŒè¿›åˆ¶æ–‡ä»¶åœ¨ä¸€èµ·ï¼Œæˆ–è€…é€šè¿‡ç¯å¢ƒå˜é‡é…ç½®
const analyzerScriptPath = "../analysis/analyzer.js"

// ParseTSFile å¯åŠ¨ä¸€ä¸ª Node å­è¿›ç¨‹æ¥åˆ†æç›®æ ‡æ–‡ä»¶
func ParseTSFile(targetPath string) ([]*models.Chunk, error) {
	// 1. è·å–å½“å‰å·¥ä½œç›®å½•ï¼Œå®šä½åˆ†æå™¨è„šæœ¬
	cwd, _ := os.Getwd()
	scriptAbsPath := filepath.Join(cwd, analyzerScriptPath)

	// æ£€æŸ¥è„šæœ¬æ˜¯å¦å­˜åœ¨ (å¼€å‘é˜¶æ®µå¸¸è§é”™è¯¯)
	if _, err := os.Stat(scriptAbsPath); os.IsNotExist(err) {
		return nil, fmt.Errorf("TS analyzer not found at: %s", scriptAbsPath)
	}

	// 2. æ„é€ å‘½ä»¤: node <script> <target>
	// è¿™å®Œå…¨ç¬¦åˆä½ çš„è¦æ±‚ï¼šè¿è¡Œç¬¬ä¸‰æ–¹å¯æ‰§è¡Œæ–‡ä»¶ (node)ï¼Œä¸ä¾µå…¥ç›®æ ‡é¡¹ç›®
	cmd := exec.Command("node", scriptAbsPath, targetPath)

	// 3. æ•è·è¾“å‡º
	var out bytes.Buffer
	var stderr bytes.Buffer
	cmd.Stdout = &out
	cmd.Stderr = &stderr

	// 4. æ‰§è¡Œ
	err := cmd.Run()
	if err != nil {
		return nil, fmt.Errorf("node exec failed: %v | stderr: %s", err, stderr.String())
	}

	// 5. è§£æ JSON
	var rawChunks []struct {
		ID                string   `json:"id"`
		Type              int      `json:"type"` // TS Kind ID
		Skeleton          string   `json:"skeleton"`
		Body              string   `json:"body"`
		SymbolsReferenced []string `json:"symbols_referenced"`
	}

	if err := json.Unmarshal(out.Bytes(), &rawChunks); err != nil {
		// å¦‚æœè¾“å‡ºä¸æ˜¯ JSONï¼Œå¯èƒ½æ˜¯è„šæœ¬å´©äº†æ‰“å°äº†å †æ ˆ
		return nil, fmt.Errorf("json parse failed: %v | output: %s", err, out.String())
	}

	// 6. è½¬æ¢æ¨¡å‹
	var chunks []*models.Chunk
	for _, rc := range rawChunks {
		chunks = append(chunks, &models.Chunk{
			ID:                rc.ID,
			Type:              fmt.Sprintf("TS_Kind_%d", rc.Type), // ç®€å•æ ‡è®°ç±»å‹
			Skeleton:          rc.Skeleton,
			Body:              rc.Body,
			SymbolsDefined:    extractNameFromID(rc.ID), // ä» ID åæ¨åå­—
			SymbolsReferenced: rc.SymbolsReferenced,
			FilePath:          targetPath,
		})
	}

	return chunks, nil
}

// è¾…åŠ©å‡½æ•°ï¼šä» ID "path/to/file.ts:FuncName" ä¸­æå– "FuncName"
func extractNameFromID(id string) []string {
	// ä¿®æ­£ï¼šåˆ é™¤äº†æœªä½¿ç”¨çš„ parts å˜é‡
	// å‡è®¾ ID æ˜¯ "path:name"
	for i := len(id) - 1; i >= 0; i-- {
		if id[i] == ':' {
			return []string{id[i+1:]}
		}
	}
	return []string{"anonymous"}
} </File>

<File name="/Users/yang/SysEvoV2/models/code_mod.go"> 
package models

// CodeModification ä»£è¡¨å¯¹ä¸€ä¸ªä»£ç å—çš„åŸå­ä¿®æ”¹æ„å›¾
// è¿™æ˜¯ AI (Gemini) è¾“å‡ºçš„æ ¸å¿ƒç»“æ„
type CodeModification struct {
	// ä¸Šä¸‹æ–‡å…³è”
	FilePath string `json:"file_path" description:"Required. The target file path."`

	// æ ¸å¿ƒå®šä½: ChunkID
	// æ ¼å¼: "path/to/file.go:FuncName" æˆ– "path/to/file.go:TypeName"
	// å¦‚æœæ˜¯æ–°å¢æ–‡ä»¶æˆ–å…¨å±€è¿½åŠ ï¼Œç•™ç©ºæˆ–ä½¿ç”¨ "EOF"
	TargetChunkID string `json:"target_chunk_id" description:"Required. The ID of the code chunk to modify. e.g. 'main.go:User.Save'."`

	// å˜æ›´ç±»å‹
	ActionType string `json:"action_type" description:"One of: 'MODIFY', 'DELETE', 'CREATE_FILE'"`

	// æ–°ä»£ç å†…å®¹
	// å¿…é¡»æ˜¯å®Œæ•´çš„ AST èŠ‚ç‚¹ä»£ç ï¼ˆåŒ…å«ç­¾åã€æ³¨é‡Šå’Œå‡½æ•°ä½“ï¼‰
	NewContent string `json:"new_content" description:"The complete new code for this chunk. Must be valid Go/TS code."`

	// æ€ç»´é“¾ (CoT)
	Reasoning string `json:"reasoning" description:"Why this change is necessary."`
}

// Solution ä»£è¡¨é’ˆå¯¹ä¸€ä¸ªç›®æ ‡çš„ä¸€ç»„ä¿®æ”¹æ–¹æ¡ˆ
type Solution struct {
	Modifications []*CodeModification `json:"modifications"`
	Status        string              `json:"status"` // "PENDING", "APPLIED", "FAILED"
} </File>

<Chunk id="/Users/yang/SysEvoV2/storage/index_client.go:DirtyIndexClient"> 
type DirtyIndexClient struct{} </Chunk>

<Chunk id="/Users/yang/SysEvoV2/llm/tool.go:Name"> 
func (t *Tool[v]) Name() string {
	return t.Tool.Function.Name
} </Chunk>

<Chunk id="/Users/yang/SysEvoV2/workflow/goal_runner.go:GoalRunner.ExecuteGoal"> 
func (r *GoalRunner) ExecuteGoal(goal string, contextSelectModel, CodeImproveModel *llm.Model) error {
	// 1. è·å–ä¸Šä¸‹æ–‡ (è¿”å›çš„æ˜¯ SelectedContext ç»“æ„ä½“)
	selectedCtx, err := r.Selector.SelectRelevantChunks(goal, contextSelectModel)
	if err != nil {
		return err
	}

	var contextStr string

	// A. å¿…é¡»åŒ…å«çš„é‡è¦æ–‡ä»¶ (README ç­‰)
	for _, file := range r.Selector.FilesMustInclude {
		// é˜²æ­¢ä¸è‡ªåŠ¨å‡æ ¼çš„æ–‡ä»¶é‡å¤ï¼Œè¿™é‡Œå¯ä»¥åŠ ä¸ªåˆ¤æ–­ï¼Œæˆ–è€…ç›´æ¥è¦†ç›–
		// å‡è®¾ FilesMustInclude ä¼˜å…ˆçº§æœ€é«˜
		if _, alreadyPromoted := selectedCtx.FullFiles[file]; !alreadyPromoted {
			contextStr += fmt.Sprintf("<File name=\"%s\"> \n%s </File>\n\n", file, utils.ReadFile(file))
		}
	}

	// B. è‡ªåŠ¨å‡æ ¼çš„å…¨é‡æ–‡ä»¶ (Scheme B Result)
	for path, content := range selectedCtx.FullFiles {
		contextStr += fmt.Sprintf("<File name=\"%s\"> \n%s </File>\n\n", path, content)
	}

	// C. å‰©ä½™çš„é›¶æ•£ Chunks
	for _, c := range selectedCtx.Chunks {
		contextStr += fmt.Sprintf("<Chunk id=\"%s\"> \n%s </Chunk>\n\n", c.ID, c.Body)
	}

	// ä¿å­˜åˆ°æœ¬åœ°ä»¥ä¾¿è°ƒè¯•
	r.ExportContextToFile(goal, contextStr)

	if CodeImproveModel == nil {
		return nil
	}

	// 2. è°ƒç”¨ç”Ÿæˆ
	return r.EditorAgent.Call(map[string]any{
		agent.UseModel: CodeImproveModel,
		"Goal":         goal,
		"Context":      contextStr,
	})
} </Chunk>

<Chunk id="/Users/yang/SysEvoV2/llm/tool.go:Tool"> 
type Tool[v any] struct {
	openai.Tool
	GoogleFunc genai.FunctionDeclaration
	Functions  []func(param v)
} </Chunk>

<Chunk id="/Users/yang/SysEvoV2/utils/cannicalHash.go:ID"> 
func ID(v interface{}, Idlength ...int) string {
	IdLen := append(Idlength, 6)[0]
	var inputString string
	switch v := v.(type) {
	case string:
		inputString = v
	case []byte:
		inputString = string(v)
	default:
		inputString = fmt.Sprintf("%v", time.Now().UnixNano())
	}

	// ä½¿ç”¨ xxhash è®¡ç®—å“ˆå¸Œ
	hashValue := xxhash.Sum64String(inputString)

	// ç”Ÿæˆå¤§æ•´æ•°å¹¶è½¬ä¸º base62 ç¼–ç çš„å­—ç¬¦ä¸²
	result := new(big.Int).SetUint64(uint64(hashValue)).Text(62)[:IdLen]

	return result
} </Chunk>

<Chunk id="/Users/yang/SysEvoV2/llm/tool.go:NewTool"> 
func NewTool[v any](name string, description string, fs ...func(param v)) *Tool[v] {
	vType := reflect.TypeOf(new(v)).Elem()
	for vType.Kind() == reflect.Ptr {
		vType = vType.Elem()
	}

	oaiProperties := make(map[string]any)
	googleProperties := make(map[string]*genai.Schema)

	// Initialize the visited map to prevent infinite recursion
	visited := make(map[reflect.Type]bool)

	if vType.Kind() == reflect.Struct {
		for i := 0; i < vType.NumField(); i++ {
			field := vType.Field(i)
			desc := field.Tag.Get("description")
			if desc == "-" {
				continue
			}

			// è·å–å­—æ®µåç§°ï¼ˆä¼˜å…ˆä½¿ç”¨ json tagï¼‰
			paramName := getFieldName(field)
			if paramName == "-" {
				continue
			}

			// Generate the schema for each field's type using the recursive helper.
			fieldOAI, fieldGoogle := buildSchemaForType(field.Type, visited)

			// The description from the tag belongs to the property definition itself.
			fieldOAI["description"] = desc
			fieldGoogle.Description = desc

			oaiProperties[paramName] = fieldOAI
			googleProperties[paramName] = fieldGoogle
		}
	} else {
		log.Printf("Warning: Tool %s is created with a non-struct parameter type. No parameters will be defined.", name)
	}

	// Construct the final top-level schema object that describes the tool's parameters.
	oaiParams := map[string]any{
		"type":       "object",
		"properties": oaiProperties,
	}
	googleSchema := &genai.Schema{
		Type:       genai.TypeObject,
		Properties: googleProperties,
	}

	a := &Tool[v]{
		Tool: openai.Tool{
			Type: openai.ToolTypeFunction,
			Function: &openai.FunctionDefinition{
				Name:        name,
				Description: description,
				Parameters:  oaiParams,
			},
		},
		GoogleFunc: genai.FunctionDeclaration{
			Name:        name,
			Description: description,
			Parameters:  googleSchema,
		},
		Functions: fs,
	}
	return a
} </Chunk>

<Chunk id="/Users/yang/SysEvoV2/analysis/indexer.go:RunParallelIndexing"> 
func RunParallelIndexing(roots []string, numThreads int) error {
	if numThreads <= 0 {
		numThreads = 1
	}

	var wg sync.WaitGroup
	// ä½¿ç”¨ç¼“å†² channel ä½œä¸ºä¿¡å·é‡é™åˆ¶å¹¶å‘åç¨‹æ•°
	semaphore := make(chan struct{}, numThreads)
	// ç”¨äºæ•è·å¹¶å‘è¿‡ç¨‹ä¸­çš„é”™è¯¯
	errChan := make(chan error, len(roots))

	fmt.Printf("ğŸš€ Starting parallel indexing with %d threads...\n", numThreads)

	for _, root := range roots {
		wg.Add(1)
		go func(path string) {
			defer wg.Done()

			// è·å–ä¿¡å·é‡ï¼ˆå¦‚æœè¾¾åˆ° numThreads åˆ™é˜»å¡ï¼‰
			semaphore <- struct{}{}
			defer func() { <-semaphore }() // é‡Šæ”¾ä¿¡å·é‡

			fmt.Printf("ğŸ§µ Thread processing: %s\n", path)

			if err := RunIncrementalIndexing(path); err != nil {
				fmt.Printf("âŒ Error indexing %s: %v\n", path, err)
				errChan <- err
			}
		}(root)
	}

	wg.Wait()
	close(errChan)

	if len(errChan) > 0 {
		return fmt.Errorf("parallel indexing completed with %d errors", len(errChan))
	}

	fmt.Println("âœ… Parallel indexing finished successfully.")
	return nil
} </Chunk>

<Chunk id="/Users/yang/SysEvoV2/analysis/indexer.go:RunIncrementalIndexing"> 
func RunIncrementalIndexing(projectRoot string) error {
	return filepath.Walk(projectRoot, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}
		if info.IsDir() {
			// å¿½ç•¥å¸¸è§éä»£ç ç›®å½•
			if strings.HasPrefix(info.Name(), ".") || info.Name() == "vendor" || info.Name() == "node_modules" {
				return filepath.SkipDir
			}
			return nil
		}

		ext := filepath.Ext(path)
		if ext != ".go" && ext != ".ts" && ext != ".tsx" {
			return nil
		}

		// 2. å¢é‡æ£€æŸ¥ (Check Metadata)
		lastMod, _ := storage.FileMetaKey.HGet(path)
		if info.ModTime().Unix() <= lastMod {
			return nil // è·³è¿‡æœªä¿®æ”¹æ–‡ä»¶
		}

		fmt.Printf("ğŸ” Indexing: %s\n", path)

		// 3. è§£æä»£ç  (Parse)
		var chunks []*models.Chunk
		var parseErr error

		if ext == ".go" {
			chunks, parseErr = ParseGoFile(path)
		} else {
			// å‡è®¾ ParseTSFile åœ¨åŒåŒ…ä¸‹çš„ parser_ts_sidecar.go ä¸­å®šä¹‰
			chunks, parseErr = ParseTSFile(path)
		}

		if parseErr != nil {
			fmt.Printf("âš ï¸ Parse Error %s: %v\n", path, parseErr)
			return nil
		}

		// 4. å­˜å‚¨ä¸ç´¢å¼• (Store & Index)
		for _, chunk := range chunks {
			chunk.UpdatedAt = time.Now().Unix()

			// A. å­˜å‚¨ Chunk å†…å®¹ (Hash)
			if _, err := storage.ChunkStorage.HSet(chunk.ID, chunk); err != nil {
				fmt.Printf("âŒ DB Error: %v\n", err)
			}

			// B. ã€æ ¸å¿ƒä¿®å¤ã€‘å»ºç«‹åå‘ç´¢å¼• (Set: Symbol -> ChunkIDs)
			// è¿™ä½¿å¾— Selector å¯ä»¥é€šè¿‡ Symbol æ‰¾åˆ°å®šä¹‰å®ƒçš„ Chunk
			for _, symbol := range chunk.SymbolsDefined {
				if len(symbol) < 2 {
					continue
				}
				// å†™å…¥ Redis Set: sys/idx/sym/{symbol}
				if err := storage.Indexer.AddSymbolLink(symbol, chunk.ID); err != nil {
					fmt.Printf("âš ï¸ Index Error: %v\n", err)
				}
			}
		}

		// 5. æ›´æ–°å…ƒæ•°æ® (æ ‡è®°è¯¥æ–‡ä»¶å·²å¤„ç†)
		storage.FileMetaKey.HSet(path, info.ModTime().Unix())

		return nil
	})
} </Chunk>

<Chunk id="/Users/yang/SysEvoV2/agent/agent.go:Agent"> 
type Agent struct {
	Models                      []*llm.Model
	PromptTemplate              *template.Template
	Tools                       []openai.Tool
	ToolInSystemPrompt          bool
	ToolInUserPrompt            bool
	toolsCallbacks              map[string]func(Param interface{}, CallMemory map[string]any) error
	functioncallParsers         []func(resp openai.ChatCompletionResponse) (toolCalls []*FunctionCall)
	CallBack                    func(ctx context.Context, inputs string) error
	CheckToolCallsBeforeCalling func(toolCalls []*FunctionCall) error
	// CallBackBeforeToolCall func(toolCall *FunctionCall, CallMemory map[string]any) error

	ToolCallRunningMutext interface{}
} </Chunk>

<Chunk id="/Users/yang/SysEvoV2/analysis/indexer.go:ParseGoFile"> 
func ParseGoFile(path string) ([]*models.Chunk, error) {
	content, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}

	fset := token.NewFileSet()
	node, err := parser.ParseFile(fset, path, content, parser.ParseComments)
	if err != nil {
		return nil, err
	}

	var chunks []*models.Chunk

	// éå† AST é¡¶çº§å£°æ˜
	for _, decl := range node.Decls {
		switch d := decl.(type) {
		case *ast.FuncDecl:
			// æå–å‡½æ•°æˆ–æ–¹æ³•
			chunks = append(chunks, extractGoFunc(d, fset, path, content))
		case *ast.GenDecl:
			// æå–ç±»å‹å®šä¹‰ (struct, interface)
			for _, spec := range d.Specs {
				if typeSpec, ok := spec.(*ast.TypeSpec); ok {
					chunks = append(chunks, extractGoType(d, typeSpec, fset, path, content))
				}
			}
		}
	}

	return chunks, nil
} </Chunk>

<Chunk id="/Users/yang/SysEvoV2/llm/model.go:Model"> 
type Model struct {
	Client          *openai.Client
	ApiKey          string // API key for authentication
	SystemMessage   string
	BaseURL         string // Base URL for the OpenAI API, can be empty for default
	Name            string
	TopP            float32
	TopK            float32
	Temperature     float32
	ToolInPrompt    *ToolInPrompt
	avgResponseTime time.Duration
	lastReceived    time.Time
	requestPerMin   float64
	mutex           sync.RWMutex
} </Chunk>

