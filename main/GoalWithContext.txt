<Goal>
 æ£€æŸ¥è„æ‰©æ•£çš„åŠŸèƒ½ä»£ç æ˜¯å¦ç¬¦åˆé¢„æœŸã€‚
</Goal>

// Important File: /Users/yang/SysEvoV2/README.md
<File name="/Users/yang/SysEvoV2/README.md"> 
è¿™æ˜¯ä¸€ä»½åŸºäºä¹‹å‰æ‰€æœ‰è®¨è®ºã€ä»£ç å®ç°åŠæ–°éœ€æ±‚ï¼ˆå‰åç«¯ä¸€ä½“åŒ–ã€å¤šç›®å½•æ”¯æŒï¼‰é‡æ–°æ•´ç†çš„**SysEvoV2 é¡¹ç›®æŠ€æœ¯è§„æ ¼è¯´æ˜ä¹¦**ã€‚

è¿™ä»½æ–‡æ¡£å»é™¤äº†æ‰€æœ‰æ–‡å­¦æ€§éšå–»ï¼Œé‡‡ç”¨äº†å·¥ç¨‹åŒ–ã€ç²¾ç¡®çš„æè¿°ï¼Œç¡®ä¿å®ç°æ—¶æ— æ­§ä¹‰ã€‚

---

# é¡¹ç›®è§„æ ¼è¯´æ˜ä¹¦ï¼šSysEvoV2 (è‡ªåŠ¨åŒ–ä»£ç æ¼”è¿›ç³»ç»Ÿ)

**ç‰ˆæœ¬:** v2.1 (Engineering Spec)
**æ—¥æœŸ:** 2026-01-20
**çŠ¶æ€:** å¼€å‘ä¸­ (In Development)
**ç¡¬ä»¶åŸºå‡†:** 8x NVIDIA RTX 3090 (192GB VRAM), Local Context Limit: 65k Tokens
**ç›®æ ‡æ¶æ„:** å‰åç«¯ä¸€ä½“åŒ– Monorepo (Golang + TypeScript)

---

## 1. ç³»ç»Ÿæ¦‚è¿° (System Overview)

SysEvoV2 æ˜¯ä¸€ä¸ªåŸºäº **AST æ„ŸçŸ¥** å’Œ **æ··åˆæ£€ç´¢** çš„è‡ªåŠ¨åŒ–ä»£ç ä¿®æ”¹ç³»ç»Ÿã€‚å®ƒæ—¨åœ¨è§£å†³å¤§è§„æ¨¡ä»£ç åº“ä¸­â€œä¸Šä¸‹æ–‡é€‰æ‹©ä¸å‡†â€å’Œâ€œè¡Œå·ä¿®æ”¹å¹»è§‰â€çš„æ ¸å¿ƒé—®é¢˜ã€‚

**æ ¸å¿ƒå·¥ä½œæµï¼š**

1. **ç´¢å¼• (Indexing):** å°†å¤šç›®å½•ä¸‹çš„æºç è§£æä¸º AST è¯­ä¹‰å— (Chunks) å¹¶å»ºç«‹ç¬¦å·ç´¢å¼•ã€‚
2. **ç­›é€‰ (Selection):** åŸºäºæ„å›¾åˆ©ç”¨æœ¬åœ° LLM ç­›é€‰éª¨æ¶ï¼Œå¹¶ç»“åˆç¬¦å·ç´¢å¼•è¿›è¡Œç¡®å®šæ€§ä¾èµ–æ‰©æ•£ã€‚
3. **ç”Ÿæˆ (Generation):** åˆ©ç”¨äº‘ç«¯ LLM ç”ŸæˆåŸºäº AST èŠ‚ç‚¹çš„å®Œæ•´æ›¿æ¢ä»£ç ã€‚
4. **åº”ç”¨ (Application):** é€šè¿‡æœ¬åœ° AST å®šä½è¿›è¡Œç²¾å‡†çš„ä»£ç æ›¿æ¢ä¸æ ¼å¼åŒ–ã€‚

---

## 2. è¯¦ç»†æ¶æ„è®¾è®¡ (Detailed Architecture)

ç³»ç»Ÿç”±ä¸‰ä¸ªæ ¸å¿ƒå­ç³»ç»Ÿç»„æˆï¼š**åˆ†æå±‚ (Analysis)**ã€**ä¸Šä¸‹æ–‡å±‚ (Context)**ã€**æ‰§è¡Œå±‚ (Execution)**ã€‚

### 2.1 ç»„ä»¶ Aï¼šä»£ç åº“åˆ†æä¸ç´¢å¼• (Codebase Analysis & Indexing)

è´Ÿè´£å°†é™æ€æ–‡ä»¶è½¬æ¢ä¸ºå¯æŸ¥è¯¢çš„è¯­ä¹‰æ•°æ®ç»“æ„ã€‚

* **è¾“å…¥:** * é…ç½®çš„ **æ ¹ç›®å½•åˆ—è¡¨ (Root Directories)**ï¼ˆæ”¯æŒå‰åç«¯å¤šç›®å½•ï¼Œå¦‚ `["./backend", "./frontend"]`ï¼‰ã€‚
* **æ ¸å¿ƒæ¨¡å—:** `analysis/indexer.go`
* **å¤„ç†æµç¨‹:**
1. **å¢é‡æ‰«æ:** éå†æŒ‡å®šç›®å½•ï¼Œå¯¹æ¯” `sys/files/meta` ä¸­çš„ä¿®æ”¹æ—¶é—´æˆ³ï¼Œä»…å¤„ç†å˜åŠ¨æ–‡ä»¶ã€‚
2. **AST åˆ‡åˆ† (Chunking):**
* **Golang:** ä½¿ç”¨ `go/ast` æå– `FuncDecl`, `GenDecl` (Struct/Interface)ã€‚
* **TypeScript:** è°ƒç”¨ Node.js Sidecar (`analyzers/ts/index.js`) è§£æ ASTã€‚
* **ç²’åº¦:** æœ€å°å•ä½ä¸ºâ€œè¯­ä¹‰å— (Chunk)â€ï¼ŒåŒ…å«å‡½æ•°ç­¾åã€æ³¨é‡ŠåŠå®Œæ•´å‡½æ•°ä½“ã€‚


3. **å…ƒæ•°æ®æå–:**
* `SymbolsDefined`: è¯¥å—å®šä¹‰çš„æ ‡è¯†ç¬¦ï¼ˆå¦‚å‡½æ•°åã€ç»“æ„ä½“åï¼‰ã€‚
* `SymbolsReferenced`: è¯¥å—å†…éƒ¨è°ƒç”¨çš„æ‰€æœ‰æ ‡è¯†ç¬¦ï¼ˆç”¨äºæ„å»ºä¾èµ–å›¾ï¼‰ã€‚


4. **æŒä¹…åŒ– (Storage):**
* **Chunk æ•°æ®:** å­˜å…¥ Redis Hash `sys/chunks`ã€‚
* **ç¬¦å·ç´¢å¼•:** å­˜å…¥ Redis Set `sys/idx/sym/{symbol}` (å€’æ’ç´¢å¼•: ç¬¦å· -> ChunkIDåˆ—è¡¨)ã€‚





### 2.2 ç»„ä»¶ Bï¼šä¸Šä¸‹æ–‡é€‰æ‹©å™¨ (Context Selector)

è´Ÿè´£æ ¹æ®ç”¨æˆ·æ„å›¾æ„å»ºæœ€å°ä¸”å®Œå¤‡çš„ä»£ç ä¸Šä¸‹æ–‡ã€‚

* **è¾“å…¥:** ç”¨æˆ·æ„å›¾ (Intent string)ã€‚
* **æ ¸å¿ƒæ¨¡å—:** `context/selector.go`
* **å¤„ç†æµç¨‹:**
1. **Level 0 (åŠ è½½):** ä» Redis åŠ è½½æ‰€æœ‰ Chunk çš„ **éª¨æ¶ (Skeleton)** (ä»…ç­¾å+æ³¨é‡Šï¼Œæ— å®ç°)ã€‚
2. **Level 1 (è¯­ä¹‰ç­›é€‰):** * å°†æ„å›¾å’Œéª¨æ¶åˆ—è¡¨è¾“å…¥æœ¬åœ° LLM (Agent/GLM-4.7)ã€‚
* LLM è¾“å‡ºä¸ä»»åŠ¡ç›´æ¥ç›¸å…³çš„ ChunkID åˆ—è¡¨ (JSON æ ¼å¼)ã€‚


3. **Level 2 (ä¾èµ–æ‰©æ•£):**
* éå† Level 1 é€‰ä¸­ Chunk çš„ `SymbolsReferenced`ã€‚
* æŸ¥è¯¢ `sys/idx/sym/*` ç´¢å¼•ï¼Œå¼ºåˆ¶æ‹‰å–å®šä¹‰äº†è¿™äº›ç¬¦å·çš„ Chunk (1-Hop ä¾èµ–)ã€‚
* *ç›®çš„:* ç¡®ä¿äº‘ç«¯æ¨¡å‹æ‹¥æœ‰ç±»å‹å®šä¹‰å’Œå·¥å…·å‡½æ•°çš„ä¸Šä¸‹æ–‡ï¼Œé¿å…å¹»è§‰ã€‚


4. **è¾“å‡º:** åŒ…å«å®Œæ•´ä»£ç ä½“ (Body) çš„ Chunk åˆ—è¡¨ã€‚



### 2.3 ç»„ä»¶ Cï¼šç”Ÿæˆä¸ç¼–è¾‘ (Generation & Editing)

è´Ÿè´£ç”Ÿæˆä¿®æ”¹æ–¹æ¡ˆå¹¶å®‰å…¨åœ°åº”ç”¨åˆ°ç£ç›˜ã€‚

* **è¾“å…¥:** å®Œæ•´ä¸Šä¸‹æ–‡ Chunk åˆ—è¡¨ + ç”¨æˆ·æ„å›¾ã€‚
* **æ ¸å¿ƒæ¨¡å—:** `workflow/goal_runner.go`, `editing/ast_editor.go`
* **ç”Ÿæˆç­–ç•¥ (Cloud Agent):**
* æ¨¡å‹: Google Gemini 3.0ã€‚
* åè®®: è¾“å‡º `CodeModification` ç»“æ„ã€‚
* **çº¦æŸ:** ç¦æ­¢ä½¿ç”¨è¡Œå·ã€‚å¿…é¡»ä½¿ç”¨ `TargetChunkID` å®šä½ï¼Œå¹¶æä¾›å®Œæ•´çš„ `NewContent` (AST èŠ‚ç‚¹å…¨é‡æ›¿æ¢)ã€‚


* **åº”ç”¨ç­–ç•¥ (AST Patching):**
1. **å®šä½:** è¯»å–ç›®æ ‡æ–‡ä»¶ï¼Œå®æ—¶è§£æ ASTï¼Œæ ¹æ® `TargetChunkID` (å¦‚ `User.Save`) åŒ¹é…æœ€æ–°çš„ Byte Offset (Start, End)ã€‚
2. **æ›¿æ¢:** æ‰§è¡Œå­—èŠ‚çº§æ›¿æ¢ã€‚
* *Modify:* æ›¿æ¢æŒ‡å®šèŒƒå›´ã€‚
* *Delete:* åˆ é™¤æŒ‡å®šèŒƒå›´ã€‚
* *Create/Append:* å†™å…¥æ–°æ–‡ä»¶æˆ–è¿½åŠ åˆ°æ–‡ä»¶æœ«å°¾ã€‚


3. **ä¿®å¤:** è°ƒç”¨ `goimports` (Go) æˆ– `prettier` (TS) è‡ªåŠ¨ä¿®å¤å¯¼å…¥è·¯å¾„å’Œæ ¼å¼ã€‚



---

## 3. æ•°æ®ç»“æ„è§„èŒƒ (Data Schema)

åŸºäº Doptime Framework çš„å­˜å‚¨å®šä¹‰ã€‚

### 3.1 å­˜å‚¨é”® (Storage Keys)

| Key Pattern | ç±»å‹ | ç”¨é€” |
| --- | --- | --- |
| `sys/chunks` | `Hash<string, *Chunk>` | å­˜å‚¨ä»£ç å—å®ä½“ã€‚Field ä¸º ChunkIDã€‚ |
| `sys/files/meta` | `Hash<string, int64>` | å­˜å‚¨æ–‡ä»¶ä¿®æ”¹æ—¶é—´æˆ³ï¼Œç”¨äºå¢é‡æ£€æŸ¥ã€‚ |
| `sys/idx/sym/{symbol}` | `Set<string>` | ç¬¦å·å€’æ’ç´¢å¼•ã€‚å­˜å‚¨å®šä¹‰è¯¥ç¬¦å·çš„ ChunkID é›†åˆã€‚ |
| `sys/solutions` | `Hash<string, *Solution>` | å­˜å‚¨ç”Ÿæˆçš„ä¿®æ”¹æ–¹æ¡ˆå†å²ã€‚ |

### 3.2 æ ¸å¿ƒæ¨¡å‹ (Models)

**Chunk (ä»£ç åŸå­)**

```go
type Chunk struct {
    ID                string   `json:"id"`                 // "filepath:Signature"
    Type              string   `json:"type"`               // "Function" | "Struct"
    Skeleton          string   `json:"skeleton"`           // ç­¾å + æ³¨é‡Š
    Body              string   `json:"body"`               // å®Œæ•´ä»£ç 
    SymbolsDefined    []string `json:"symbols_defined"`    // å®šä¹‰çš„ç¬¦å·
    SymbolsReferenced []string `json:"symbols_referenced"` // è°ƒç”¨çš„ç¬¦å·
    FilePath          string   `json:"file_path"`
}

```

**CodeModification (ä¿®æ”¹æŒ‡ä»¤)**

```go
type CodeModification struct {
    FilePath      string `json:"file_path"`
    TargetChunkID string `json:"target_chunk_id"` // é”šç‚¹ ID
    ActionType    string `json:"action_type"`     // MODIFY | DELETE | CREATE_FILE
    NewContent    string `json:"new_content"`     // å®Œæ•´çš„æ–° AST èŠ‚ç‚¹ä»£ç 
    Reasoning     string `json:"reasoning"`
}

```

---

## 4. å®æ–½è·¯çº¿å›¾ (Implementation Roadmap)

### Phase 1: åŸºç¡€æ¶æ„æ„å»º (Infrastructure)

* [x] **å­˜å‚¨å±‚:** å®ç° Redis Key å®šä¹‰ (`storage/keys.go`, `storage/index_client.go`)ã€‚
* [x] **è§£æå±‚ (Go):** å®ç° `go/ast` è§£æå™¨ (`analysis/parser_go.go`)ã€‚
* [x] **è§£æå±‚ (TS):** å®ç° Node.js Sidecar è§£æå™¨ (`analysis/parser_ts_sidecar.go`)ã€‚
* [ ] **ç´¢å¼•å™¨:** æ›´æ–° `RunIncrementalIndexing` ä»¥æ”¯æŒä¼ å…¥**ç›®å½•åˆ‡ç‰‡ (`[]string`)**ï¼Œå¹¶ä¸²è”è§£æä¸å­˜å‚¨é€»è¾‘ã€‚

### Phase 2: ä¸Šä¸‹æ–‡é€‰æ‹© (Context Selection)

* [ ] **Agent é›†æˆ:** ç§»æ¤æ—§ç‰ˆ Agent (`agent`, `models` åŒ…) åˆ°æ–°æ¶æ„ã€‚
* [ ] **é€‰æ‹©å™¨:** å®ç° `context/selector.go`ï¼Œè”é€šæœ¬åœ° LLM ä¸ Redis ç´¢å¼•ã€‚

### Phase 3: ç”Ÿæˆä¸æ‰§è¡Œ (Execution)

* [ ] **ç¼–è¾‘å™¨:** å®ç° `editing/ast_editor.go`ï¼Œå®ŒæˆåŸºäº AST çš„ç²¾å‡†æ›¿æ¢é€»è¾‘ã€‚
* [ ] **å·¥ä½œæµ:** å®ç° `workflow/goal_runner.go`ï¼Œä¸²è” Context -> Cloud Agent -> Editor é—­ç¯ã€‚

---

## 5. å…³é”®é£é™©ä¸è§„é¿ (Risk Management)

1. **é£é™©:** ç›®å½•éå†é—æ¼ã€‚
* *è§„é¿:* `RunIncrementalIndexing` å…¥å£å‚æ•°å¼ºåˆ¶æ”¹ä¸º `rootDirs []string`ï¼Œå¹¶åœ¨é…ç½®ä¸­æ˜ç¡®åˆ—å‡ºæ‰€æœ‰æºç æ ¹ç›®å½•ï¼ˆå¦‚ `backend/`, `frontend/src/`ï¼‰ã€‚


2. **é£é™©:** éšå¼ä¾èµ–ä¸¢å¤±ï¼ˆå¦‚ Middlewareï¼‰ã€‚
* *è§„é¿:* ç¬¦å·ç´¢å¼•é‡‡ç”¨â€œå­—ç¬¦ä¸²å¼ºåŒ¹é…â€ç­–ç•¥ï¼ˆDirty Indexï¼‰ï¼Œå®æ»¥å‹¿ç¼ºã€‚


3. **é£é™©:** ä»£ç æ›¿æ¢å¯¼è‡´ Import ä¸¢å¤±ã€‚
* *è§„é¿:* ç¼–è¾‘å™¨åœ¨å†™å…¥æ–‡ä»¶åï¼Œ**å¼ºåˆ¶æ‰§è¡Œ** `goimports` (Go) æˆ–è‡ªåŠ¨å¯¼å…¥ä¿®å¤é€»è¾‘ã€‚


4. **é£é™©:** TypeScript è§£æç¯å¢ƒä¾èµ–ã€‚
* *è§„é¿:* é‡‡ç”¨ Sidecar æ¨¡å¼ï¼Œå°† TS è§£æå™¨ä½œä¸ºç‹¬ç«‹å­è¿›ç¨‹è¿è¡Œï¼Œä¸ä¾èµ–å®¿ä¸»é¡¹ç›®çš„ `node_modules`ã€‚



---

**æŒ‡ä»¤:**
æœ¬é¡¹ç›®æ–‡æ¡£ä½œä¸ºåç»­å¼€å‘çš„**å”¯ä¸€çœŸç†æ¥æº (Single Source of Truth)**ã€‚æ‰€æœ‰ä»£ç å®ç°å¿…é¡»ä¸¥æ ¼éµå¾ªä¸Šè¿°æ•°æ®ç»“æ„ä¸æµç¨‹å®šä¹‰ã€‚ </File>

<Chunk id="/Users/yang/SysEvoV2/utils/textFromfile.go:TextFromFiles"> 
func TextFromFiles(xmlTag string, filenames ...string) string {
	var sb strings.Builder
	for _, filename := range filenames {
		content, err := os.ReadFile(filename)
		if err != nil {
			fmt.Printf("Error reading file %s: %v\n", filename, err)
			continue
		}
		text := string(content)
		text = strings.TrimSpace(text)
		if text != "" {
			sb.WriteString(fmt.Sprintf("\n<%s name=\"%s\">\n%s\n</%s>\n", xmlTag, filename, text, xmlTag))
		}
	}
	return sb.String()
} </Chunk>

<Chunk id="/Users/yang/SysEvoV2/models/models.go:Chunk"> 
type Chunk struct {
	// å”¯ä¸€æ ‡è¯†ç¬¦: "filepath:start_byte-end_byte"
	// msgpack: æ•°æ®åº“å­˜å‚¨å­—æ®µå
	ID string `json:"id" msgpack:"id"`

	// ç±»å‹: "Function", "Struct", "Interface"
	Type string `json:"type" msgpack:"type"`

	// éª¨æ¶: ä»…ç­¾å + æ³¨é‡Š (ç”¨äº Level 1 æ„å›¾ç­›é€‰)
	Skeleton string `json:"skeleton" msgpack:"skeleton"`

	// å…¨æ–‡: å®Œæ•´çš„ä»£ç å®ç° (ç”¨äº Level 3 ç”Ÿæˆ)
	Body string `json:"body" msgpack:"body"`

	// ç¬¦å·è¡¨: å®šä¹‰äº†ä»€ä¹ˆç¬¦å·
	SymbolsDefined []string `json:"symbols_defined" msgpack:"symbols_defined"`

	// å¼•ç”¨è¡¨: è°ƒç”¨äº†ä»€ä¹ˆç¬¦å· (ç”¨äºæ„å»ºè„é“¾æ¥å›¾)
	SymbolsReferenced []string `json:"symbols_referenced" msgpack:"symbols_referenced"`

	// æ–‡ä»¶å…ƒæ•°æ®: ç”¨äºå¢é‡æ›´æ–°æ£€æŸ¥
	FilePath  string `json:"file_path" msgpack:"file_path"`
	UpdatedAt int64  `json:"updated_at" msgpack:"updated_at"` // Unix Timestamp
} </Chunk>

<Chunk id="/Users/yang/SysEvoV2/utils/cannicalHash.go:ID"> 
func ID(v interface{}, Idlength ...int) string {
	IdLen := append(Idlength, 6)[0]
	var inputString string
	switch v := v.(type) {
	case string:
		inputString = v
	case []byte:
		inputString = string(v)
	default:
		inputString = fmt.Sprintf("%v", time.Now().UnixNano())
	}

	// ä½¿ç”¨ xxhash è®¡ç®—å“ˆå¸Œ
	hashValue := xxhash.Sum64String(inputString)

	// ç”Ÿæˆå¤§æ•´æ•°å¹¶è½¬ä¸º base62 ç¼–ç çš„å­—ç¬¦ä¸²
	result := new(big.Int).SetUint64(uint64(hashValue)).Text(62)[:IdLen]

	return result
} </Chunk>

<Chunk id="/Users/yang/SysEvoV2/context/selector.go:Selector.expandDependencies"> 
func (s *Selector) expandDependencies(seeds []string, allChunks map[string]*models.Chunk) map[string]struct{} {
	resultSet := make(map[string]struct{})
	for _, id := range seeds {
		resultSet[id] = struct{}{}
	}

	for _, id := range seeds {
		chunk, ok := allChunks[id]
		if !ok {
			continue
		}
		for _, refSymbol := range chunk.SymbolsReferenced {
			targetIDs, _ := storage.Indexer.GetSymbolLinks(refSymbol)
			for _, tid := range targetIDs {
				if _, exists := allChunks[tid]; exists {
					resultSet[tid] = struct{}{}
				}
			}
		}
	}
	return resultSet
} </Chunk>

<Chunk id="/Users/yang/SysEvoV2/context/selector.go:Selector.SelectRelevantChunks"> 
func (s *Selector) SelectRelevantChunks(intent string, model *llm.Model) ([]*models.Chunk, error) {
	fmt.Printf("ğŸ§  Selecting Context for: %.50s...\n", intent)

	allChunksMap, _ := storage.ChunkStorage.HGetAll()
	allChunks := lo.Values(allChunksMap)

	var sb strings.Builder
	for _, c := range allChunks {
		skel := c.Skeleton
		if len(skel) > 400 {
			skel = skel[:400] + "..."
		}
		sb.WriteString(fmt.Sprintf("ID: %s\n%s\n---\n", c.ID, skel))
	}

	// æ ¸å¿ƒï¼šä½¿ç”¨é—­åŒ…æ•è·é€‰ä¸­çš„ ID
	var finalIDs []string
	s.SelectionAgent = s.SelectionAgent.UseTools(llm.NewTool("PickChunks", "Select necessary code chunks (IDs)", func(res *SelectionResult) {
		finalIDs = res.SelectedIDs
	}))

	// è°ƒç”¨ Agent
	err := s.SelectionAgent.Call(map[string]any{
		agent.UseModel:   model,
		"ImportantFiles": utils.TextFromFiles("ImportantFile", s.FilesMustInclude...),
		"Intent":         intent,
		"Candidates":     sb.String(),
	})
	if err != nil {
		return nil, err
	}

	// è„æ‰©æ•£ (Level 2)
	finalIDSet := s.expandDependencies(finalIDs, allChunksMap)

	result := make([]*models.Chunk, 0)
	for id := range finalIDSet {
		if chunk, ok := allChunksMap[id]; ok {
			result = append(result, chunk)
		}
	}
	return result, nil
} </Chunk>

<Chunk id="/Users/yang/SysEvoV2/storage/index_client.go:DirtyIndexClient.GetSymbolLinks"> 
func (c *DirtyIndexClient) GetSymbolLinks(symbol string) ([]string, error) {
	key := fmt.Sprintf("sys/idx/sym/%s", symbol)

	// SMembers è¿”å› []v, error
	return redisdb.NewSetKey[string, string](redisdb.WithKey(key)).SMembers()
} </Chunk>

<Chunk id="/Users/yang/SysEvoV2/storage/index_client.go:DirtyIndexClient"> 
type DirtyIndexClient struct{} </Chunk>

<Chunk id="/Users/yang/SysEvoV2/llm/tool.go:NewTool"> 
func NewTool[v any](name string, description string, fs ...func(param v)) *Tool[v] {
	vType := reflect.TypeOf(new(v)).Elem()
	for vType.Kind() == reflect.Ptr {
		vType = vType.Elem()
	}

	oaiProperties := make(map[string]any)
	googleProperties := make(map[string]*genai.Schema)

	// Initialize the visited map to prevent infinite recursion
	visited := make(map[reflect.Type]bool)

	if vType.Kind() == reflect.Struct {
		for i := 0; i < vType.NumField(); i++ {
			field := vType.Field(i)
			desc := field.Tag.Get("description")
			if desc == "-" {
				continue
			}

			// Generate the schema for each field's type using the recursive helper.
			fieldOAI, fieldGoogle := buildSchemaForType(field.Type, visited)

			// The description from the tag belongs to the property definition itself.
			fieldOAI["description"] = desc
			fieldGoogle.Description = desc

			oaiProperties[field.Name] = fieldOAI
			googleProperties[field.Name] = fieldGoogle
		}
	} else {
		log.Printf("Warning: Tool %s is created with a non-struct parameter type. No parameters will be defined.", name)
	}

	// Construct the final top-level schema object that describes the tool's parameters.
	oaiParams := map[string]any{
		"type":       "object",
		"properties": oaiProperties,
	}
	googleSchema := &genai.Schema{
		Type:       genai.TypeObject,
		Properties: googleProperties,
	}

	a := &Tool[v]{
		Tool: openai.Tool{
			Type: openai.ToolTypeFunction,
			Function: &openai.FunctionDefinition{
				Name:        name,
				Description: description,
				Parameters:  oaiParams,
			},
		},
		GoogleFunc: genai.FunctionDeclaration{
			Name:        name,
			Description: description,
			Parameters:  googleSchema,
		},
		Functions: fs,
	}
	return a
} </Chunk>

